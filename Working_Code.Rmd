---
title: "Final DAVIS Project"
author: "Chandler"
date: "4/13/2019"
output: html_document
---

# Introduction: 
So far in DAVis we have created static maps, which are useful in itself for creating figures for reports and presentations. However, sometimes we may want our audience to interact with the data! This is where `leaflet` comes in - the `leaflet` package overlays your data on top of interactive maps.


Leaflet is a popular interactive mapping library written in JavaScript. Leaflet enables you to build the control widget directly while using the map. Every layer you create must be added to the same map, all attributed to a “group“. Then, the control widget will allow you to switch from one group to another.


```{r, echo = FALSE}
#install.packages("leaflet")
library(leaflet)
```

Our first example of using `leaflet()` is to map out the best city in the US: Seattle! As we learned recently, we will use the pipe operator %>% in the `magrittr` package in order to write our program most effectively. While this may not make much sense at the moment, we will explain what both `addTiles()` and `addMarkers()` means later. For now, you just need to know that we are building the images of the map thru `addTiles()` and specifying which city is the best city in the US thru its longitude and latitude coordinates and labeling it with `addMarkers()`.
```{r}
seattle <- leaflet() %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addMarkers(lng=-122.335167, lat=47.608013, popup="The Best City in the US!")
seattle
```

For the sake of clarity in explaining the standalone functions, without the pipe operator, the first example would have looked like this: 

```{r}
seattle <- leaflet()
seattle <- addTiles(seattle) 
seattle <- addMarkers(seattle, lng=-122.335167, lat=47.608013, popup="The Best City in the US!")
seattle
```
Going forward, for the sake of consistency, the rest of the report will be using the pipe operator in our R scripts. 


# The Map Widget

### `leaflet()` function

The `leaflet()` function returns a Leaflet map widget, which stores a list of objects that can be modified or updated later. The map widget displays an interactive map control.

### Initializing Options
The map widget can be initialized with certain parameters. This is achieved by populating the options argument as shown below.

The most important Map State Options in `leaflet()` are:

1. `crs`: The Coordinate Reference System to use.

2. `center`: The initial geographic center of the map

3. `minZoom`: Minimum zoom level of the map.

4. `maxZoom`: Maximum zoom level of the map.

5. `layers`: Array of layers that will be added to the map initially.

For an extensive list of options outside the scope of this report, please click here[https://leafletjs.com/reference-1.3.0.html#map-option]. 

In this example below, we change the options of the Map Widget by restricting the Maximum Zoom level of the map of the best city in the US. Try changing the value in the `minZoom` and `maxZoom` in order to see the different effect the zoom settings can have on the map.
```{r}
seattle <- leaflet(options = leafletOptions(minZoom = 0, maxZoom = 8)) %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addMarkers(lng=-122.335167, lat=47.608013, popup="The Best City in the US!")
seattle
```

### Map Methods
Below are a series of methods to manipulate the map further. 

1. `setView()` sets the center of the map view and the zoom level.

```{r}
setView(seattle, lng=-122.335167, lat=47.608013, zoom = 10)
```


2. `fitBounds()` fits the view into the rectangle [lng1, lat1] – [lng2, lat2]. `fitBounds()` takes the following parameters: fitBounds(map, lng1, lat1, lng2, lat2, options = list())

3. `clearBounds()` clears the bound, so that the view will be automatically determined by the range of latitude/longitude data in the map layers if provided. `clearBounds()` takes the following parameters: clearBounds(map)

# Base Maps

The Base Map is the perfect starting place for learning `leaflet()`. The function of the basemap is to provide fundamental information of the map, acting as a base or a starting point. Then, additional data of specialized nature are compiled or overprinted the base map. The method that we will be focusing on for adding data to the Base Maps is called tiled maps. 

### Tiled Maps

In recent years, as a result of GoogleMaps, the most popular way to display and navigate maps online is to use *tiled maps*. A tiled map is a map that is displayed in a browser that appears to be one large map image, but is really just a number of smaller images, or tiles, drawn next to each other. 

Tiled maps enable everyone to have access to high-quality maps, regardless of their hardware or devices. When displaying a tiled map, only the images covering the geographic area currently being displayed are required. 

One must add tiles to their Base Map in order to get the image of the map to be displayed as the actual geographics you are trying to display. 

In `leaflet()`, the easiest way to add tiles is by calling `addTiles()` with no arguments; by default, OpenStreetMap tiles are used. OpenStreetMap is built by a community of mappers that contribute and maintain data about roads, trails, cafés, railway stations, and much more, all over the world.

```{r}
m <- leaflet() %>% setView(lng = -71.0589, lat = 42.3601, zoom = 12)
m %>% addTiles()
```

# Markers

Now that we have a great base map, we want to be able to visualize our data here. To do so, we 
use markers to call out points on the map. Marker locations are expressed in latitude/longitude coordinates, and can either appear as icons or as circles.

### Icon Markers
Icon markers are added using the `addMarkers()` or the `addAwesomeMarkers()` functions. The default icon is a *dropped pin*. As with most layer functions, the popup argument can be used to add a message to be displayed on click, and the label option can be used to display a text label either on hover or statically.

```{r}
leaflet(data = quakes[1:20,]) %>% addTiles() %>%
  addMarkers(~long, ~lat, popup = ~as.character(mag), label = ~as.character(mag))
```

In addition to having default icons, you can also make your own icon using the `makeIcon()` function. To make a custom icon, you usually need two images — the actual icon image and the image of its shadow. However, this is out of the scope of this project. 

### Awesome Markers Leaflet Plugin.
Leaflet supports even more customizable markers using the awesome markers leaflet plugin.

The `addAwesomeMarkers()` function is similar to `addMarkers()` function but additionally allows you to specify custom colors for the markers as well as additional icons from numerous different libraries (such as the Font Awesome, Bootstrap Glyphicons, and Ion icons icon libraries).

```{r}
df.20 <- quakes[1:20,]

getColor <- function(quakes) {
  sapply(quakes$mag, function(mag) {
  if(mag <= 4) {
    "green"
  } else if(mag <= 5) {
    "orange"
  } else {
    "red"
  } })
}

icons <- awesomeIcons(
  icon = 'ios-close', # the icon argument needs to be the name of any valid icon supported by the the respective library (below two lines)
  iconColor = 'black',
  library = 'ion', # The library argument has to be one of ‘ion’, ‘fa’, or ‘glyphicon’
  markerColor = getColor(df.20)
)

leaflet(df.20) %>% addTiles() %>%
  addAwesomeMarkers(~long, ~lat, icon=icons, label=~as.character(mag))
```
For the sake of this project, we will be using the `ion` library. You can view the extensive list of icons here[https://ionicons.com/]. 

##### Marker Clusters
When there are a large number of markers on a map, you can cluster them using the argument `clusterOptions`. 

In order to make the clusters static, or freeze in their groupings at a specified zoom level, you will need to pass in the argument `freezeAtZoom`. Regardless how far you zoom in, after the variable, or in this instance '5', the clusters become static.

```{r}
leaflet(quakes) %>% addTiles() %>% addMarkers(
  clusterOptions = markerClusterOptions(freezeAtZoom = 5)
)
```

Circle markers are much like regular circles (see Lines and Shapes), except that their radius in onscreen pixels stays constant regardless of zoom level.

```{r}
leaflet(quakes) %>% addTiles() %>% addCircleMarkers()

```

# Popups and Labels
Another significant addition Popups are small boxes containing arbitrary HTML, that point to a specific point on the map.

### Pop ups
Use the `addPopups()` function to add a single, standalone popup to your given map.
-15.56
167.62

```{r}
content <- "This is where the largest quake happended in the quakes dataset!"
leaflet() %>% addTiles() %>%
  addPopups(167.62, -15.56, content,
    options = popupOptions(closeButton = FALSE)
  )
```

Popups are typically used when the marker or shape is clicked.  Marker and shape functions in the Leaflet package take a popup argument, where you can pass in HTML to easily attach a simple popup.


```{r}
library(htmltools)

df <- read.csv(textConnection(
"Name,Long,Lat
Magnitude: 6.4, 167.62, -15.56
Magnitude: 6.1, 169.92, -20.70
Magnitude: 6.0, 65.96, -13.64"
))

leaflet(df) %>% addTiles() %>%
  addMarkers(~Long, ~Lat, popup = ~htmlEscape(Name))
```

The last argument in the above example, `htmltools::htmlEscape` was used to santize any characters in the name that might be interpreted as HTML. While we did not need it here, it is important to incldue this argument in order to ensure there is no unnecessary errors due to their being a misinterpretation of the strings. 


### Labels
A label is a HTML comment on markers and shapes that is either always displayed or displayed on when the mouse is held over the marker. Unlike popups, you don’t need to click a marker/polygon for the label to be shown.

You can also customize marker labels using the `labelOptions` argument of the `addMarkers()` function. The `labelOptions` argument can be populated using the `labelOptions()` function. View ?labelOptions for a comprehensive list of possible options for labeling elements. 

```{r}
library(htmltools)

df <- read.csv(textConnection(
"Name,Long,Lat
Magnitude: 6.4, 167.62, -15.56
Magnitude: 6.1, 169.92, -20.70
Magnitude: 6.0, 65.96, -13.64"
))

leaflet(df) %>% addTiles() %>%
  addMarkers(~Long, ~Lat,
             label = "6.0 > magnitude",
             labelOptions = labelOptions(noHide = T, textsize = "15px")) %>%
  addMarkers()

```

Finally, one can also add labels without the accompanying markers using the `addLabelOnlyMarkers()` function.

# Lines and Shapes
Another thing `leaflet()` enables you to do is to add spatial lines and shapes to your maps.



# Colors
An important part of any type of visualizations in both static and interactive maps is colors. Colors enable us to highlight different trends, identify distinct variables, and even help convey our findings more directly. While we have already studied colors in DAVis, there is a useful tool that can help you generate your own perfect color palette.

```{r}
# Call the color function (colorNumeric) to create a new palette function
pal <- colorNumeric(c("pink", "purple", "blue"), 1:20)
# Pass the palette function a data vector to get the corresponding colors
pal(c(3, 7, 19))
```

When using `colorNumeric()`, even if the palette contains a limited number of colors, `colorNumeric()` will interpolates these colors so we get continuous output. The `domain` parameter indicates the input values that we are mapping to the colors. Other functions that operate in a similar regard are:

1. `colorBin()`, which maps numeric input data to a fixed number of output colors using binning.

2. `colorQuantile()`, which maps numeric input data to a fixed number of output colors using quantiles. 

3. `colorFactor()`, which maps categorical variables. We will be discussing this further in the next subsection. 

```{r}
# This creates a continuous color palette
pal <- colorNumeric(
  palette = "Blues",
  domain = co2) 
```

The function will return the corresponding colors in Hexadecimal. However, it is important to note that the following examples and exercises are able to pass in different arguments into the colors function in the following regards: a palette from the RColorBrewer package, a character vector of RGB or named colors, and the full name of a viridis palette. 

### Coloring categorical data
When working with categorical data, we should use `colorFactor()`. 

The mapping of the colors and of the categorical variable will be one-to-one if the palette contains the same number of elements as there are factor levels. Otherwise, the palette will be interpolated to produce the desired number of colors.

**INSERT EXAMPLE** ... need polygons and lines section for this ! 



